<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <title>Symmetry reduced Flag-hierarchies</title>
    <link rel="shortcut icon" href="./favicon.ico" />
    <link rel="stylesheet" href="./dist/reset.css" />
    <link rel="stylesheet" href="./dist/reveal.css" />
    <link rel="stylesheet" href="./dist/theme/night.css" id="theme" />
    <link rel="stylesheet" href="./css/highlight/zenburn.css" />


  </head>
  <body>
    <div class="reveal">
      <div class="slides"><section  data-markdown><script type="text/template">
$$\require{color}$$
<!-- reveal-md slides.md -w --theme night -->
<!-- reveal-md slides.md --theme night --static _site -->
<!-- Then copy videos! -->
<!-- and remove _asset paths -->
## Symmetry reduced Flag-hierarchies

<br/>

### Daniel Brosch
<!-- #### Tilburg University -->
April 1, 2022
</script></section><section  data-markdown><script type="text/template">
## Contents

- Semidefinite programming <!-- .element: class="fragment" data-fragment-index="1"-->
- Symmetry reduction basics <!-- .element: class="fragment" data-fragment-index="2" -->
- Representation theory <!-- .element: class="fragment" data-fragment-index="3" -->
<span class="fragment" data-fragment-index="4" style="color:orange">(of $S_n$) </span>
- Flag-Algebras <!-- .element: class="fragment" data-fragment-index="5" -->
- Lasserre style hierarchy <!-- .element: class="fragment" data-fragment-index="6" -->
- Razborov style hierarchy <!-- .element: class="fragment" data-fragment-index="7" -->

<div class="r-stack">

$$ \inf\\{\langle C,X\rangle : \langle A_i, X\rangle = b_i \forall i, X\succcurlyeq 0\\} $$ <!-- .element: class="fragment fade-in-then-out" data-fragment-index="1"-->

![](Pic_SymReduc.svg) <!-- .element: class="fragment fade-in-then-out" data-fragment-index="2"-->

![](Pic_YoungTab.svg) <!-- .element: class="fragment fade-in-then-out" data-fragment-index="4"-->

$$V = m_1S_1\oplus m_2S_2\oplus \ldots \oplus m_kS_k$$ <!-- .element: class="fragment fade-in-then-out" data-fragment-index="3"-->


![](Pic_FlagExample.svg) <!-- .element: class="fragment fade-in-then-out" data-fragment-index="5"-->

<img class="r-stretch" src="Pic_SpechtFlags.svg"><!-- .element: class="fragment fade-in-then-out" data-fragment-index="6"-->

<img class="r-stretch" src="Pic_MaxCliques.svg"><!-- .element: class="fragment fade-in-then-out" data-fragment-index="7"-->

</div></script></section><section ><section data-markdown><script type="text/template">
## Semidefinite programming

<br />

<div class="r-stack">

$$ \inf_X\\{\langle C,X\rangle : \langle A_i, X\rangle = b_i \forall i, X\succcurlyeq 0\\} $$ <!-- .element: class="fragment fade-out" data-fragment-index="1" -->

$$ \inf_X\\{\langle C,X\rangle : \langle A_i, X\rangle = b_i \forall i, \fcolorbox{orange}{black}{$X\succcurlyeq 0$}\\} $$ <!-- .element: class="fragment fade-in-then-out" data-fragment-index="1" -->

</div> 
</script></section><section data-markdown><script type="text/template">
### The anatomy of an SDP

<div class="r-stack">

$$ \inf_X\\{\langle C,X\rangle : \langle A_i, X\rangle = b_i \forall i, X\succcurlyeq 0\\} $$ <!-- .element: class="fragment fade-out" data-fragment-index="1" -->

$$ \inf_X\\{\langle {\color{orange}C},X\rangle : \langle {\color{orange}A_i}, X\rangle = b_i \forall i, X\succcurlyeq 0\\} $$ <!-- .element: class="fragment fade-in-then-out" data-fragment-index="1" -->

$$ \inf_X\\{{\color{orange}\langle} C{\color{orange},}X{\color{orange}\rangle} : {\color{orange}\langle} A_i{\color{orange},}X{\color{orange}\rangle} = b_i \forall i, X\succcurlyeq 0\\} $$ <!-- .element: class="fragment fade-in-then-out" data-fragment-index="2" -->

$$ \inf_X\\{\langle C,X\rangle : \langle A_i, X\rangle = b_i \forall i, \fcolorbox{orange}{black}{$X\succcurlyeq 0$}\\} $$ <!-- .element: class="fragment fade-in-then-out" data-fragment-index="3" -->

$$ \inf_X\\{\langle C,X\rangle : \langle A_i, X\rangle = b_i \forall i, X\succcurlyeq 0\\} $$ <!-- .element: class="fragment fade-in-then-out" data-fragment-index="4" -->

</div> 

<br />

<div class="r-stack">

<div>$\color{orange} C, A_i\in\mathbb{S}^{n\times n}$ are symmetric data matrices </div> <!-- .element: class="fragment fade-in-then-out" data-fragment-index="1" -->

<div>$\color{orange} \langle\cdot,\cdot\rangle$ denotes the matrix inner product: $$\langle A,B\rangle = \sum_{i,j=1}^n A_{ij} B_{ij}$$ </div> <!-- .element: class="fragment fade-in-then-out" data-fragment-index="2" -->

$ \color{orange} X\succcurlyeq 0 $ means that $X$ is **positive semidefinite**: $$v^TXv\geq 0 \text{ for all vectors } v.$$  
<!-- .element: class="fragment fade-in-then-out" data-fragment-index="3" -->

SDPs are **linear optimization problems** over a **convex cone**. We can solve them in **polynomial time!**
<!-- .element: class="fragment fade-in-then-out" data-fragment-index="4" -->
</div> 
</script></section><section data-markdown><script type="text/template">
### SDPs for polynomial optimization

<div class="r-stack">

<span class="fragment fade-out" data-fragment-index="1">

We often want to minimize a polynomial under some polynomial constraints:

$$\min_x \\{{\color{green}f}(x): {\color{red}g_i}(x)\geq 0 \quad\forall i\\}.$$

</span>

<span class="fragment fade-in" data-fragment-index="1">
We can rewrite this problem as 

$$ \max_{\lambda, s} \\{\lambda : {\color{green}f}-\lambda = {\color{orange}s_0} + \sum_i {\color{orange}s_i} {\color{red}g_i} \geq 0\\},$$
where the $\color{orange}s_j$ are **nonnegative polynomials**.
</span>
</div>
</script></section><section data-markdown><script type="text/template">
### Sums-of-Squares



<span class="r-stack">
<span class="fragment fade-out" data-fragment-index="1">

We can relax the nonnegative polynomials $\color{orange}s_j$ to be **sums of squares** of polynomials:

$${\color{orange}s_j}(x) = \sum_{t} p_t(x)^2 \geq 0.$$

</span>

<span class="fragment fade-in-then-out" data-fragment-index="1">

Given a polynomial basis 
$${\color{red}[x]}=\\{1, x_1, x_2, x_1^2, x_1x_2,\ldots\\}$$
we can write the squared polynomials in the form
\begin{align}
p_t(x)^2 &= \left({\color{red}[x]}^Tv_t\right)^2\\\\
&= {\color{red}[x]}^T\left(v_tv_t^T\right)  {\color{red}[x]}.
\end{align}

</span>

<span class="fragment fade-in" data-fragment-index="2">

$${\color{orange}s_j}(x) ={\color{red}[x]}^T\left(\sum_t  v_t v_t^T\right)  {\color{red}[x]} =  {\color{red}[x]}^T X  {\color{red}[x]},$$

where $X$ is **positive semidefinite**.

</span>

</span>
<span class="fragment fade-in" data-fragment-index="3" style="color:orange">
Comparing coefficients leads to a standard SDP!
</span>


</script></section></section><section ><section data-markdown><script type="text/template">
## SDP Symmetry reduction basics

<br />

![](Pic_SymReduc.svg) <!-- .element: class="r-stretch" -->
</script></section><section data-markdown><script type="text/template">
### What is a symmetry?


<br />

Let ${\color{orange}\sigma}$ be a **permutation** of $\\{1,\ldots, n\\}$. We let ${\color{orange}\sigma}$ act on the *indices of $X$ simultanously*:

$${\color{orange}\sigma}(X) = \left(X_{{\color{orange}\sigma}(i){\color{orange}\sigma}(j)}\right)_{i,j=1}^n.$$

<br />

<span class="fragment fade-in" style="color:orange">If $X$ is positive semidefinite, then $\sigma(X)$ is as well!</span>
</script></section><section data-markdown><script type="text/template">
### When does an SDP have a symmetry?

 
<div class="r-stack">

An SDP has symmetry ${\color{orange}\sigma}$, if ${\color{orange}\sigma}$ sends feasible solutions to feasible solutions with the same objective value. <!-- .element: class="fragment fade-out" data-fragment-index="1" -->

<span class="fragment fade-in" data-fragment-index="1">


This holds if for each constraint $\langle A_i,X\rangle=b_i$ there is a $j$ such that
 $${\color{orange}\sigma}(A_i)=A_j, \quad b_i=b_j$$
and the objective is symmetric:
$${\color{orange}\sigma}(C)=C.$$

</span></div>

</script></section><section data-markdown><script type="text/template">

### How do we exploit symmetries?


The set of all symmetries forms a **group ${\color{orange}G}$** of permutations. As the feasible set of an SDP is **convex**, we can **average** feasible solutions:

$$\mathcal{R}(X) = \frac{1}{|{\color{orange}G}|} \sum_{{\color{orange}\sigma}\in {\color{orange}G}}{\color{orange}\sigma}(X)$$


<span class="fragment fade-in" style="color:orange">

$\mathcal{R}(X)$ is again feasible, with the same objective value as $X$!

</span>
</script></section><section data-markdown><script type="text/template">
### Symmetric optimal solutions

<div class="r-stack">

<span class="fragment fade-out" data-fragment-index="1">
If $X^*$ is an optimal solution, then so is $\mathcal{R}(X^*)$. This solution is <span style="color:orange">invariant under actions of ${\color{orange}G}$</span>:
$${\color{orange}\sigma}(\mathcal{R}(X^*)) = \mathcal{R}(X^*). $$
</span>
<span class="fragment fade-in-then-out" data-fragment-index="1">

We can restrict the SDP to optimize only over <span style="color:orange">invariant</span> matrices:
\begin{align}
\inf\enspace&\langle C,X\rangle \\\\
\text{s.t.}\enspace& \langle A_i, X\rangle = b_i\quad \text{for all } i,\\\\
& X\succcurlyeq 0,\\\\
& {\color{orange}\mathcal{R}(X)=X}.\\\\
\end{align}

</span>
<span class="fragment fade-in-then-out" data-fragment-index="2">

In the case of ${\color{orange}G}=D_{10}=C_5\times Z_2$ we can restrict $X$ to have the **pattern**

$$\begin{pmatrix}
{\color{red}A} & {\color{orange}B} & {\color{green}C} & {\color{green}C} & {\color{orange}B}\\\\
{\color{orange}B} & {\color{red}A} & {\color{orange}B} & {\color{green}C} & {\color{green}C}\\\\
{\color{green}C} & {\color{orange}B} & {\color{red}A} & {\color{orange}B} & {\color{green}C}\\\\
{\color{green}C} & {\color{green}C} & {\color{orange}B} & {\color{red}A} & {\color{orange}B} \\\\
{\color{orange}B} & {\color{green}C} & {\color{green}C} & {\color{orange}B} & {\color{red}A}\\\\
\end{pmatrix}$$ 
</span>
</div>
</script></section><section data-markdown><script type="text/template">
### Block-diagonalization
<div class="r-stack">

<span class="fragment fade-out" data-fragment-index="1">

$$\tiny\begin{pmatrix}
{\color{red}A} & {\color{orange}B} & {\color{green}C} & {\color{green}C} & {\color{orange}B}\\\\
{\color{orange}B} & {\color{red}A} & {\color{orange}B} & {\color{green}C} & {\color{green}C}\\\\
{\color{green}C} & {\color{orange}B} & {\color{red}A} & {\color{orange}B} & {\color{green}C}\\\\
{\color{green}C} & {\color{green}C} & {\color{orange}B} & {\color{red}A} & {\color{orange}B} \\\\
{\color{orange}B} & {\color{green}C} & {\color{green}C} & {\color{orange}B} & {\color{red}A}\\\\
\end{pmatrix}
$$

is positive semidefinite if and only if

* ${\color{red}A} + {\color{orange}B} + {\color{green}C} \geq 0$,
* ${\color{red}A} +\frac{\sqrt{5}-1}{4}{\color{orange}B} - \frac{\sqrt{5}+1}{4}{\color{green}C} \geq 0$,
* ${\color{red}A} -\frac{\sqrt{5}+1}{4}{\color{orange}B}+\frac{\sqrt{5}-1}{4}{\color{green}C} \geq 0$.

</span>
<span class="fragment fade-in" data-fragment-index="1">
In general we may still get multiple bigger blocks

![](Pic_SymReduc.svg)

but <span style="color:orange">the sum of the block sizes is often significantly lower than $n$!</span>

<span class="fragment fade-in" data-fragment-index="2" style="color:red">
How do we find the block-diagonalization?
</span>

</span>
</div>



<aside class="notes"><p>This linearizes the problem.</p>
</aside></script></section></section><section ><section data-markdown><script type="text/template">
## Representation theory 

$$V = m_1W_1\oplus m_2W_2\oplus \ldots \oplus m_kW_k$$
</script></section><section data-markdown><script type="text/template">
### A ${\color{orange}G}$-module is
 
- a **vectorspace** $V$,
- a **group** ${\color{orange}G}$, and
- a **group homomorphism** $\rho:{\color{orange}G}\to \mathrm{GL}(V)$.

<br/><br/>

Together, they let ${\color{orange}G}$ act on vectors:

$$\color{orange}\boxed{gv := \rho(g)v}$$

<aside class="notes"><p>The image of the group homomorphism is a matrix representation, if one fixes a basis.</p>
</aside></script></section><section data-markdown><script type="text/template">### Example: ${\color{orange}S_n}$-module

The vectorspace of polynomials up to degree $d$ in $n$ variables:
$$\mathbb{R}[x_1,\ldots,x_n]_{\leq d}$$
is an ${\color{orange}S_n}$-module by defining

$${\color{orange}\sigma}(x_i) := x_{{\color{orange}\sigma}(i)}$$

and extending the operation to polynomials.

<aside class="notes"><p>Depending on if a left or right action is used for permutations, we may need to invert sigma.</p>
</aside></script></section><section data-markdown><script type="text/template">
### Irreducible modules

We call a ${\color{orange}G}$-module $V$ **irreducible**, if $V$ and $\\{0\\}$ are the only submodules of $V$.

<br />

<span class="fragment fade-in">
<div class="r-frame">
The $\color{orange}S_2$-module 

$$V = \mathrm{span}\\{1,x_1,x_2\\}$$

is not irreducible:

\begin{align}
V =& \enspace{\color{orange}\mathrm{span}\\{1\\}} \oplus {\color{orange}\mathrm{span}\\{x_1+x_2\\}}\\\\&\oplus {\color{green}\mathrm{span}\\{x_1 - x_2\\}}\\\\
\end{align}

</div>
</span>

<aside class="notes"><p>First two submodules are isomorphic!</p>
</aside></script></section><section data-markdown><script type="text/template">
### Maschke's Theorem

<span class="r-stack">
<span class="fragment fade-out" data-fragment-index="1">

We can decompose $\color{orange}G$-modules into irreducible submodules:

$$ V = W_1\oplus \ldots \oplus W_k.$$

</span>
<span class="fragment fade-in-then-out" data-fragment-index="1">

Sorting by equivalent (isomorphic) submodules, we see that 

$$V\simeq {\color{orange}m_1}S_1 \oplus \ldots\oplus {\color{orange}m_h}S_h,$$

where the ${\color{orange}m_i}$ are nonnegative integers, and the $S_i$ form a set of **all irreducible $G$-modules** up to isomorphism. 

</span>

<span class="fragment fade-in" data-fragment-index="3">

\begin{align}
V =& \enspace \mathrm{span}\\{1,x_1,x_2\\}\\\\
=&\enspace{\color{orange}\mathrm{span}\\{1\\}} \oplus {\color{orange}\mathrm{span}\\{x_1+x_2\\}}\\\\&\oplus {\color{green}\mathrm{span}\\{x_1 - x_2\\}}\\\\
\simeq&\enspace {\color{orange}2S^{(2)}} \oplus {\color{green}S^{(1,1)}}\\\\ 
\end{align}

The irreducible modules $S^\lambda$ of $S_n$ are called **Specht modules**.

</span>
</span>
</script></section><section data-markdown><script type="text/template">
### Schur's Lemma
#### The main ingredient of block-diagonalization

<br/>

<div class="r-frame">

Let $\color{orange}M$, $\color{orange}N$ be two **irreducible** $G$-modules over a ring $R$. Let ${\color{limegreen}\varphi} : {\color{orange}M}\to {\color{orange}N}$ be a homomorphism.

- If $\color{orange}M$ and $\color{orange}N$ are not isomorphic, then ${\color{limegreen}\varphi} \equiv 0$. <!-- .element: class="fragment"-->
- If ${\color{orange}M}\simeq {\color{orange}N}$ and $R$ is an algebraically closed field, then ${\color{limegreen}\varphi} = c\mathrm{I}$ for a $c\in R$. <!-- .element: class="fragment"-->

</div>
</script></section><section data-markdown><script type="text/template">
### Symmetry adapted basis

A "<span style="color:green">nice</span>" basis, which respects the decomposition
 $$V\simeq {\color{orange}m_1}S_1 \oplus \ldots\oplus {\color{orange}m_h}S_h,$$
is called **symmetry adapted basis** of $V$.

<br/>

"<span style="color:green">Nice</span>" essentially means that we choose the same basis in each copy of each $S_i$.
</script></section><section data-markdown><script type="text/template">
### Block-diagonalization

<span class="r-stack">
<span class="fragment fade-out" data-fragment-index="1">

Let $G$ now act on $\mathbb{C}^n$ via $\sigma(e_i) = e_{\sigma(i)}$. Swapping the basis of the SDP to a symmetry adapted basis of $\mathbb{C}^n$ **block-diagonalizes** the SDP:


</span>
<span class="fragment fade-in" data-fragment-index="1">
If $\mathbb{C}^n\simeq {\color{orange}m_1}S_1 \oplus \ldots\oplus {\color{orange}m_h}S_h,$

we obtain <span style="color:orange">$h$ different blocks of sizes $\color{orange}m_1, \ldots, m_h$</span>

each appearing with $\dim(S_i)$ identical copies.



</span>
</span>

![](Pic_SymReduc.svg)

<aside class="notes"><p>$G$ acts on the index space of $X$. We can delete the copies.</p>
</aside></script></section></section><section ><section data-markdown><script type="text/template">## Representation theory of ${\color{orange}S_n}$

![](Pic_YoungTab.svg)
</script></section><section data-markdown><script type="text/template">
### Permutation modules

<span class="r-stack">

<span class="fragment fade-out" data-fragment-index="1">

Let ${\color{orange}\lambda} = (\lambda_1,\ldots, \lambda_m)\in\mathbb{N}^m$ be a **partition** of $n$:

- $\lambda_1 \geq \lambda_2\geq \ldots\geq \lambda_m>0$,
- $\lambda_1+\ldots+\lambda_m = n$.

</span>
<span class="fragment fade-in-then-out" data-fragment-index="1">

A **Young-tableau** of *shape* $\color{orange}\lambda$ consists of $n$ boxes, positioned on $m$ rows, with $\lambda_i$ boxes in row $i$, and filled bijectively with $\\{1,\ldots,n\\}$.

<br/>

![](Pic_YoungTabEx.svg)

is a Young-tableau of shape $\color{orange}{(3,2)}$.

</span>
<span class="fragment fade-in-then-out" data-fragment-index="2">

A **Young-tabl<ins>oid</ins>** is the *row-equivalence* class of a Young-tableau:

![](Pic_YoungTabloidEx.svg)

</span>
<span class="fragment fade-in-then-out" data-fragment-index="3">

Finally, a **Permutation module** of shape $\color{orange}\lambda$ is the $\color{orange}{S_n}$-module

$$M^{\color{orange}\lambda} := \mathrm{span}_\mathbb{R}\\{ \text{Young-tabloids of shape } {\color{orange}\lambda}\\},$$

where $\color{orange}{S_n}$ acts on the <span style="color:orange">entries</span> of each box individually:


![](Pic_PermModEx.svg)

</span>

</span>
</script></section><section data-markdown><script type="text/template">
### Specht modules

<span class="r-stack">
<span class="fragment fade-out" data-fragment-index="1">

We can determine an <span style="color:orange">irreducible</span> submodule of each $M^{\color{orange}\lambda}$, called **Specht module** of shape $\color{orange}\lambda$.

</span>
<span class="fragment fade-in-then-out" data-fragment-index="1">

Specht modules are the span of **polytabloids** in $M^{\color{orange}\lambda}$. Let $t$ be a Young-tabl<ins>eau</ins> of shape ${\color{orange}\lambda}$. Then

$$e_t:= \sum_{\sigma \in C_t}\mathrm{sgn}(\sigma)\\{\sigma t\\} \in M^{\color{orange}\lambda},$$

where $C_t$ is the *column-stabilizer* of $t$.

</span>
<span class="fragment fade-in-then-out" data-fragment-index="2">

For example, let $\color{orange}{\lambda=(4,2)}$, and 

![](Pic_PolytabExA.svg)

The *column-stabilizer* of $t$ is $C_t=S_{\color{orange}\\{1,5\\}}\times S_{\color{green}\\{2,6\\}}$, and the **polytabloid** of $t$ is:


![](Pic_PolytabExB.svg)

</span>

<span class="fragment fade-in" data-fragment-index="3">

Specht modules are the span of **polytabloids** in $M^{\color{orange}\lambda}$:


$$S^{\color{orange}\lambda} := \mathrm{span}\\{e_t : t \text{ tableau of shape } {\color{orange}\lambda}\\} \subseteq M^{\color{orange}\lambda}$$

<span class="fragment fade-in" data-fragment-index="4" style="color:orange">Specht modules are irreducible, and form a complete set of irreducible modules of $S_n$!</span>

</span>
</span>
</script></section><section data-markdown><script type="text/template">
#### Decomposing Permutation modules

<div class="r-stack">
<div class="fragment fade-out" data-fragment-index="1">

Often, the main idea for block-diagonalizing problems with $\color{orange}{S_n}$-symmetry is:

<br/>

<div class="r-frame">

- Decompose $V$ into copies of <span style="color:orange">Permutation modules</span>.
- Decompose each Permutation module further into <span style="color:orange">Specht modules</span>.

</div>

<br/>

The decomposition of Permutation modules is well understood!

</div>


<div class="fragment fade-out" data-fragment-index="3">
<div class="fragment fade-in" data-fragment-index="1">

We now allow **duplicate entries** in Young-tableaux. Given two partitions ${\color{orange}\lambda}$, ${\color{green}\mu}$ of $n$, we say that a tableau $t$ of <span style="color:orange">shape</span> ${\color{orange}\lambda}$ has <span style="color:green">content</span> ${\color{green}\mu}$, if $t$ has ${\color{green}{\mu_1}}$ ones, ${\color{green}{\mu_2}}$ twos, etc.

<br />

<div class="fragment fade-in" data-fragment-index="2"><div class="r-frame">

![](Pic_YoungTableauEx.svg)

is a tableau of <span style="color:orange">shape</span> ${\color{orange}{(3,2)}}$ and <span style="color:green">content</span>  ${\color{green}{(2,2,1)}}$.

</div>
</div>
</div>
</div>


<div class="fragment fade-in-then-out" data-fragment-index="3">

![](Pic_YoungTableauEx.svg)

A Young-tableau is called <span style="color:orange">semistandard</span>, if its entries
- <span style="color:orange">increase</span> in rows, and
- <span style="color:orange">strictly increase</span> in columns. 


</div>

<div class="fragment fade-in-then-out" data-fragment-index="4">


Semistandard Young-tableaux $T$ of <span style="color:orange">shape</span> ${\color{orange}\lambda}$ and content <span style="color:green">content</span> ${\color{green}\mu}$ give homomorphisms 
$$\vartheta_T :  M^{\color{orange}\lambda}\to M^{\color{green}\mu}  $$
by moving entries $t(i,j)$ to the row given by $T(i,j)$, and summing over the row equivalence class of $T$.


</div>

<div class="fragment fade-in-then-out" data-fragment-index="5">

Let $T$ be the semistandard tableau

![](Pic_YoungTabExColor.svg)

of <span style="color:orange">shape</span> ${\color{orange}{(3,2)}}$ and <span style="color:green">content</span>  ${\color{green}{(2,2,1)}}$. Then


![](Pic_SemistandardHom.svg)



</div>


<div class="fragment fade-out" data-fragment-index="8">
<div class="fragment fade-in" data-fragment-index="6">

These homomorphisms form a basis of the <span style="color:orange">multiplicity space</span> of $S^\lambda$ in $M^\mu$:

$$\mathrm{Hom}(S^\lambda, M^\mu).$$


<div class="fragment fade-in" data-fragment-index="7">
The dimension of the multiplicity spaces are called <span style="color:orange">Kostka numbers $K_{\lambda\mu}$.</span>
</div>

</div>
</div>

<div class="fragment fade-in-then-out" data-fragment-index="8">

We can now explicitly decompose Permutation modules in terms of Specht modules:

$$\color{orange}M^\mu = \bigoplus_{\lambda} K_{\lambda\mu}S^\lambda.$$



</div>

<!-- <div class="fragment fade-in" data-fragment-index="9">



\begin{align}
M^{(2,1,1)} \simeq& S^{(4)} \oplus 2S^{(3,1)} \oplus S^{(2,2)}\oplus S^{(2,1,1)}.
\end{align}

</div> -->


</div>
</script></section></section><section ><section data-markdown><script type="text/template">
## Flag-Algebras

![](Pic_FlagExample.svg)

</script></section><section data-markdown><script type="text/template">
### Flag-Algebras

<span class="r-stack">
<span class="fragment fade-out" data-fragment-index="1">

Flag-Algebras were first introduced by **Alexander Razborov** in 2007, and remain one of the most powerful tools in <span style="color:orange">extremal combinatorics</span>. 

</span>
<span class="fragment fade-in" data-fragment-index="1">

They have been used to investigate to <span style="color:orange">dense limits</span> of

- graphs, <!-- .element: class="fragment" data-fragment-index="1"-->
- hypergraphs, <!-- .element: class="fragment" data-fragment-index="2"-->
- directed graphs, <!-- .element: class="fragment" data-fragment-index="3"-->
- permutations, <!-- .element: class="fragment" data-fragment-index="4"-->
- point order types, <!-- .element: class="fragment" data-fragment-index="5"-->
- and much more! <!-- .element: class="fragment" data-fragment-index="6"-->

<span> In this talk, we will focus on the case of <span style="color:orange">graphs</span>.</span> <!-- .element: class="fragment" data-fragment-index="7"-->

</span>
</span>


<aside class="notes"><p>Razborov unifies and generalizes ideas of many authors.</p>
</aside></script></section><section data-markdown><script type="text/template">
### How many edges can there be in a triangle free graph?

<video class="fv-video" src="./videos/TriangleFree.mp4" fv-playback-info="./videos/TriangleFree.json">
</video>
</script></section><section data-markdown><script type="text/template">
### Triangle free graphs

<div class="r-stack">
<div class="fragment fade-out" data-fragment-index="2">

To formally define the optimization problem, we let

$$\mathcal{G} = (G_i)_{i\geq 1}$$

be a <span style="color:orange">sequence of graphs</span>, where graph $G_i$ has $i$ vertices.

<div class="fragment fade-in" data-fragment-index="1">
The <span style="color:orange">density</span> of a graph $H$ in $\mathcal{G}$ is
$$p(\mathcal{G}, H) := \lim_{i\to\infty} \mathbb{P}[\sigma_i(H) \text{ is a subgraph of }G_i],$$
where $\sigma_i$ is a random permutation in $S_i$.
</div>
</div>
<div class="fragment fade-in" data-fragment-index="2">

Maximize the <span style="color:orange">edge density</span> in a <span style="color:green">triangle free</span> sequence $\mathcal{G}$ of graphs of increasing size:

![](Pic_EqTriangleFree.svg)

We saw that

![](Pic_EqTriangleFreeLowerBound.svg)

but how do we find an <span style="color:orange">upper bound</span>?

</div>
</div>

<aside class="notes"><p>Non-induced subgraphs count</p>
</aside></script></section><section data-markdown><script type="text/template">
### Multiplying subgraph densities



<div class="r-stack">
<div class="fragment fade-out" data-fragment-index="2">
If we multiply two subgraph densities, we <span style="color:orange">glue together</span> the graphs:

![](Pic_DensityProduct.svg)

<div class="fragment fade-in" data-fragment-index="1">
This is because the probability that the two graphs are sent to <span style="color:orange">disjoint</span> sets of vertices <span style="color:orange">converges to $1$ in the limit</span>. 
</div>
</div>
<div class="fragment fade-in-then-out" data-fragment-index="2">
These relationships are <span style="color:orange">independent of $\mathcal{G}$</span>, motivating the notation

![](Pic_DensityProductNoP.svg)

where a graph $H$ now stand for the function
$$H:\mathcal{G}\mapsto p(\mathcal{G},H).$$
</div>
<div class="fragment fade-in" data-fragment-index="3">

We can now restrict the randomly chosen permutations $\sigma_i$ to fix (<span style="color:orange">flag</span>) some vertices, and extend the <span style="color:orange">gluing</span> operation to <span style="color:orange">partially labeled graphs (Flags)</span>:

![](Pic_FlagExample.svg)

</div>
</div>
</script></section><section data-markdown><script type="text/template">
### Flag Sums-of-Squares

<div class="r-stack">
<div class="fragment fade-out" data-fragment-index="2">

As Flags send graph sequences to *real numbers*, <span style="color:orange">squaring a linear combination of Flags</span> results in a function that sends graph sequences to a <span style="color:orange">nonnegative number</span>:

![](Pic_FlagSOS1.svg)

<span class="fragment fade-in" data-fragment-index="1">A linear combination of Flags is also called a <span style="color:orange">Quantum-Flag</span>.</span>
</div>
<div class="fragment fade-in-then-out" data-fragment-index="2">
We can <span style="color:orange">average</span> Flags over all choices of labels, <span style="color:orange">unlabeling</span> them:

![](Pic_FlagSOS2.svg)

<aside class="notes"><p>Averaging preserves nonnegativity.</p>
</div>

<div class="fragment fade-in" data-fragment-index="3">

<p>We can now find an <span style="color:orange">upper bound</span> for the edge density in triangle free graphs:</p>
<p><img src="Pic_FlagSOS3.svg" alt=""></p>
<div class="fragment fade-in" data-fragment-index="4">

<p>As for <span style="color:orange">polynomial optimization</span>, we can model Flag-SOS using <span style="color:orange">semidefinite programming</span>.</p>
</div>
</div>
</div></aside></script></section><section data-markdown><script type="text/template">
### Flags as (limits of) polynomials

<div class="r-stack">
<div class="fragment fade-out" data-fragment-index="2">

Recently, **Raymond**, **Saunderson**, **Singh** and **Thomas** have proven a fascinating connection of <span style="color:orange">Flag-SOS</span> and <span style="color:orange">polynomial SOS</span>: 

<br/>

- Flags can be seen as limits of polynomials.
- <span style="color:orange">Partially</span> exploiting the polynomials' symmetries and taking the limit leads to Flag-SOS.

<span style="color:orange">We fully exploit their symmetries!</span><!-- .element: class="fragment" data-fragment-index="1"-->
</div>
<div class="fragment fade-in-then-out" data-fragment-index="2">

Maximizing the <span style="color:orange">edge density</span> in a <span style="color:green">triangle</span>-free graph can be reformulated as:

\begin{align}
    \lim_{n\to\infty}\max \enspace&{\color{orange}\frac{1}{\binom n 2}\sum_{1\leq i<j\leq n} x_{ij}}\\\\
    \text{s.t.}\enspace & {\color{green}\frac{1}{\binom{n}{3}}\sum_{1\leq i<j<k\leq n} x_{ij}x_{ik}x_{jk}} = 0,\\\\
    & x_{ij}\in\\{0,1\\} \quad \text{for all } i < j.
\end{align}

</div>
<div class="fragment fade-in" data-fragment-index="3">

We introduce <span style="color:orange">binary</span> variables corresponding to <span style="color:orange">edges</span>:

$$ x_{ij} \in \\{0,1\\} \quad \text{for } i < j. $$

<div class="fragment" data-fragment-index="4">

Subgraph densities are polynomials <span style="color:orange">invariant</span> under $\color{orange}{S_n}$ acting simultanously on the indices:

$${\color{orange}\sigma}(x_{ij}) = x_{{\color{orange}\sigma}(i){\color{orange}\sigma}(j)}.$$

<div class="fragment" data-fragment-index="5" style="color:orange">
We can exploit this symmetry!
</div>

</div>

</div>
</div>

<aside class="notes"><p>Monomials = fully labeled graphs. Action corresponds to permuting labels.</p>
</aside></script></section></section><section  data-markdown><script type="text/template">
## Main contributions

<div class="r-stack">
<div class="fragment fade-out" data-fragment-index="1">

We fully <span style="color:orange">exploit the symmetries</span> of two hierarchies:

- <span style="color:orange">Lasserre</span> hierarchy for Flags with <span style="color:orange">few edges</span>       

- <span style="color:orange">Razborov</span> hierarchy for Flags with <span style="color:orange">few vertices</span>     

</div>

<div class="fragment fade-out" data-fragment-index="5">
<div class="fragment fade-in" data-fragment-index="1">

We lay the groundwork for a few novel ideas:


<span class="fragment" data-fragment-index="2">Extension of Flag-Algebras to <span style="color:orange">degenerate extremal combinatorics</span>.</span>

<div class="fragment" data-fragment-index="3">

A <span style="color:orange">harmonic basis</span> and <span style="color:orange">Fourier decomposition</span> of Flags.

</div>

<div class="fragment" data-fragment-index="4">

A generalization of Razborov's <span style="color:orange">partial derivatives</span> of Flags.

</div>
</div>
</div>
<div class="fragment" data-fragment-index="5">
A Julia software package implementing all hierarchies for <span style="color:orange">arbitrary Flags</span> will be available soon.
</div>


</div>


</script></section><section ><section data-markdown><script type="text/template">
## Lasserre style hierarchy
#### Prioritizing Flags with <span style="color:orange">few edges</span>

<!-- <div class="r-stretch">

![](Pic_SpechtFlags.svg)

</div> -->

<img class="r-stretch" src="Pic_SpechtFlags.svg">
</script></section><section data-markdown><script type="text/template">
### The Lasserre hierarchy

<div class="r-stack">
<div class="fragment fade-out" data-fragment-index="2">

The $\color{orange}d$'th level of the <span style="color:orange">Lasserre hierarchy</span> limits the <span style="color:orange">degree</span> of appearing monomials to at most $2{\color{orange}d}$.

<br/>

<div class="fragment" data-fragment-index="1">
We optimize over sums of squares of the form

$${\color{red}[x]}^T X  {\color{red}[x]},$$

where $X\succcurlyeq 0$ and ${\color{red}[x]}$ is a basis of 
$$ \mathbb{R}[x]_{\leq {\color{orange}d}}.$$


</div>

</div>
<div class="fragment fade-in" data-fragment-index="2">

As monomials correspond to <span style="color:orange">fully labeled graphs</span>, we here have

$${\color{red}[x]} = \\{H : H \text{ graph with at most $\color{orange}d$ edges}\\}.$$

</div>
</div>



</script></section><section data-markdown><script type="text/template">
### Reduction strategy

<div class="r-stack">
<div class="fragment fade-out" data-fragment-index="3">
<span>We can <span style="color:orange">block-diagonalize</span> SDPs such as those coming from sums-of-squares.</span>

<span>To do this, we need to <span style="color:orange">decompose $\mathbb{R}[x]_{\leq d}$ into irreducible submodules</span>.</span>  <!-- .element: class="fragment" data-fragment-index="1"-->

<span>The irreducible submodules of $\color{orange}{S_n}$ are the <span style="color:orange">Specht modules $S^\lambda$</span>. </span> <!-- .element: class="fragment" data-fragment-index="2"-->
</div>
<div class="fragment fade-in" data-fragment-index="3">

We need to find a basis of the <span style="color:orange">multiplicity space</span> of each Specht module

$$\mathrm{Hom}(S^\lambda, \mathbb{R}[x]_{\leq {\color{orange}d}}).$$

<div class="fragment" data-fragment-index="4">
If we can first decompose $\mathbb{R}[x]_{\leq {\color{orange}d}}$ into <span style="color:orange">Permutation modules $M^\lambda$</span>, we can use their <span style="color:orange">well known decomposition</span>.
</div>

</div>
</div>
</script></section><section data-markdown><script type="text/template">
### Warmup: Variables with a single index

<div class="r-stack">
<div class="fragment fade-out" data-fragment-index="1">
Let's first consider a problem in variables

$$x_i\in \\{0,1\\},$$

where

$${\color{orange}\sigma}(x_i) = x_{{\color{orange}\sigma}(i)}$$

for ${\color{orange}\sigma}\in S_n$.

</div>
<div class="fragment fade-in-then-out" data-fragment-index="1">
We can decompose $\mathbb{R}[x]_{\leq {\color{orange}d}}$ into <span style="color:orange">spans of orbits of monomials</span>:

\begin{align}
\mathbb{R}[x]_{\leq {\color{orange}d}} =& \mathrm{span}\\{1\\}\\\\
&\oplus \mathrm{span}\\{x_1,x_2,\ldots\\}\\\\
&\oplus \mathrm{span}\\{x_1x_2, x_1x_3, x_2x_3,\ldots\\}\\\\
&\oplus \ldots \oplus \mathrm{span}(S_n(x_1x_2\cdot\ldots\cdot x_\{\color{orange}d\} ))\\\\
\end{align}

</div>
<div class="fragment fade-out" data-fragment-index="4">
<div class="fragment fade-in" data-fragment-index="2">

Each span of orbit of a monomial is isomorphic to a <span style="color:orange">Permutation module</span>:

$$\mathrm{span}(S_n(x_1x_2\cdot\ldots\cdot x_i )) \simeq M^{(n-i,i)}.$$

<div class="fragment" data-fragment-index="3">
For example, in the case $n=7$, we have

![](Pic_OrbitSingleIndexIso.svg)

</div>
</div>
</div>
<div class="fragment fade-in" data-fragment-index="4">

We can now decompose the polynomials up to degree $\color{orange}d$ as

$$\mathbb{R}[x]_\{\leq {\color{orange}d}\} = \bigoplus_\{i=0\}^\{\color{orange}d\}M^{(n-i,i)}, $$

and then further decompose each Permutation module into Specht modules.

</div>

</div>
</script></section><section data-markdown><script type="text/template">
### General case

<div class="r-stack">
<div class="fragment fade-out" data-fragment-index="1">
Let's attempt the same in the case of graphs. We can first decompose $\mathbb{R}[x]_{\leq {\color{orange}d}}$ into <span style="color:orange">spans of orbits of monomials</span>:

$$\mathbb{R}[x]\_\{\leq {\color{orange}d}\} = \bigoplus_{\text{Graphs $H$ with up to $\color{orange}d$ edges}}{\color{orange}M^{H,n}},$$

where the sum is taken up to isomorphism, and 

$${\color{orange}M^{H,n}} := \mathrm{span}\left(S_n\left(x^{E(H)} \right)\right).$$

</div>
<div class="fragment fade-in" data-fragment-index="1">
For example, we have

![](Pic_GraphModuleDecomp.svg)

where

![](Pic_GraphModuleEx.svg)

<div class="fragment" data-fragment-index="2">
How do we decompose these <span style="color:orange">"Graph-modules"</span>?
</div>
</div>
</div>
</script></section><section data-markdown><script type="text/template">
### Decomposing Graph-modules

<div class="r-stack">
<div class="fragment fade-out" data-fragment-index="1">
Decomposing the $S_n$-modules $M^{H,n}$ into <span style="color:orange">Specht modules</span> can be <span style="color:orange">easy in some cases:</span>

![](Pic_PathModule.svg)

by

![](Pic_PathModuleIso.svg)


</div>

<div class="fragment fade-out" data-fragment-index="3">
<div class="fragment fade-in" data-fragment-index="1">
In most cases <span style="color:red">we cannot find an isomorphism</span> between $M^{H,n}$ and a Permutation module.

<div class="fragment" data-fragment-index="2">
But we can always find isomorphisms to <span style="color:orange">quotients of permutation modules</span>, for example

![](Pic_E2Module.svg)

![](Pic_E2ModuleIso.svg)
</div>
</div>
</div>

<div class="fragment fade-in" data-fragment-index="3">

In general, we have

$${\color{orange}M^{H,n}} \simeq M^{(n-|V(H)|,1,\ldots, 1)} \color{orange} / \mathrm{Aut}(H),$$

where the automorphisms of $H$ <span style="color:orange">act on the rows of tabloids</span> in the Permutation module.

<div class="fragment" data-fragment-index="4" style="color:orange">

This generalizes Permutation-modules by taking equivalence classes over groups that are not Young-groups.

</div>

</div>


</div>

<aside class="notes"><p>Starting from the second row. We can simplify a bit if a pairwise swap is an automorphism.</p>
</aside></script></section><section data-markdown><script type="text/template">
### Decomposing $M^\lambda / {\color{orange}G}$

<div class="r-stack">
<div class="fragment fade-out" data-fragment-index="1">

We need to find a basis of the <span style="color:orange">multiplicity space</span> of each Specht-module:

$$\mathrm{Hom}(S^\mu,M^\lambda / {\color{orange}{\color{orange}G}}) \simeq \mathcal{R}_{\color{orange}G} (\mathrm{Hom}(S^\mu,M^\lambda)),$$

where $\mathcal{R}_G$ is the Reynolds operator of ${\color{orange}G}$, which <span style="color:orange">averages</span> over all group elements.

</div>
<div class="fragment fade-in" data-fragment-index="1">

We know that a basis of $\mathrm{Hom}(S^\mu,M^\lambda)$ is given by homomorphisms corresponding to <span style="color:orange">semistandard tableaux</span> of shape $\mu$ and content $\lambda$.

<br/>

<div class="fragment" data-fragment-index="2">

<span style="color:orange">Idea:</span>

1. Calculate a matrix representation of $\mathcal{R}_{\color{orange}G}$ in this basis.
2. Choose a subset of columns spanning the image of $\mathcal{R}_{\color{orange}G}$.

</div>

</div>
</div>
</script></section><section data-markdown><script type="text/template">
### Calculating $\mathcal{R}_{\color{orange}G}$: <span style="color:red">Problems</span>

<div class="r-stack">
<div class="fragment fade-out" data-fragment-index="2">

The vectors $\vartheta_T(e_t) \in M^\lambda$, where $e_t\in S^\mu$ and $\vartheta_T \in \mathrm{Hom}(S^\mu,M^\lambda)$, get <span style="color:red">extremely long</span>. In small cases we can already reach more than <span style="color:red">$100.000.000$ nonzero coefficients</span>.

<br/>

<span style="color:red">We cannot work with the vectors explicitly!</span><!-- .element: class="fragment" data-fragment-index="1"-->

</div>
<div class="fragment fade-in-then-out" data-fragment-index="2">

While we have a lot of structure in some cases, such as $\small\mathcal{R} _ {C_{20}}\left(\mathrm{Hom}\left(S^{(18,1,1)},M^{(1,\ldots,1)}\right)\right): $

<img class="r-stretch" src="RA.png">

</div>

<div class="fragment fade-in-then-out" data-fragment-index="3">

There are usually <span style="color:red">no clear patterns</span> in the Reynolds operators. <span style="color:red">Analytic solutions are unlikely.</span>

<img class="r-stretch" src="RB.png">

</div>

<div class="fragment fade-in-then-out" data-fragment-index="4">

We need to understand the action of permutations on homomorphisms in $\mathrm{Hom}(S^\mu,M^\lambda)$.

![](Pic_PermHom.svg)

$T$ is <span style="color:orange">not semistandard</span>! We need to <span style="color:orange">decompose</span> the corresponding homomorphism $\vartheta_T$ in the semistandard basis of $\mathrm{Hom}(S^\mu,M^\lambda)$.

</div>

<div class="fragment fade-in" data-fragment-index="5">

It is <span style="color:orange">known</span> that we can always decompose 

$$\vartheta_T = \sum_{T'\text{ semistandard}}c_{T'}\vartheta_{T'}.$$

<span style="color:red" class="fragment" data-fragment-index="6">But proofs in the literature are based on an existence argument. We would again need to use the very long vectors explicitly.</span>

</div>

</div>

<aside class="notes"><p>not semistandard, we would need long vector</p>
</aside></script></section><section data-markdown><script type="text/template">
### A "straightening" algorithm for generalized tableaux

<div class="r-stack">
<div class="fragment fade-out" data-fragment-index="1">
We propose an <span style="color:orange">algorithm</span> to determine the decomposition

$$\vartheta_T = \sum_{T'\text{ semistandard}}c_{T'}\vartheta_{T'}$$

in $\mathcal{O}({\color{orange}k}^2)$ steps, where $\color{orange}k$ is the number of semistandard tableaux of the <span style="color:orange">same shape and content as $T$</span>.
</div>

<div class="fragment fade-in-then-out" data-fragment-index="1">
Most of the work <span style="color:orange">is independent of $T$</span>.


<div class="r-frame">

This allows us to calculate an <span style="color:orange"> $k\times k$ matrix representation</span> of permutations $\sigma$ on $\mathrm{Hom}(S^\mu,M^\lambda):$

$$ \vartheta_T \mapsto \vartheta_{\sigma(T)}$$

in $\mathcal{O}({\color{orange}k}^2)$ steps.

</div>
</div>

<div class="fragment fade-in" data-fragment-index="2">

We can calculate the matrices corresponding to a <span style="color:orange">generator of $G$</span>, and use a <span style="color:orange">Stabilizer-chain of $G$</span> to calculate $\color{orange}{\mathcal{R}_G}$ efficiently.

<br/>

<div class="fragment" data-fragment-index="3">
A Stabilizer-chain of $G$ can be found using the <span style="color:orange">Schreier-Sims algorithm</span>.
</div>

</div>

</div>

</script></section><section data-markdown><script type="text/template">
<img class="r-stretch" src="Pic_Algo.svg">
</script></section><section data-markdown><script type="text/template">
### Example

While $\color{orange}M^{(4,2,2)}$ decomposes into $\color{orange}14$ Specht-modules,
\begin{align} 
{\color{orange}M^{(4,2,2)}}/ \langle(2\enspace 3)\rangle=& S^{(4,2,2)}\oplus S^{(4,4)}\\\\
&\oplus S^{(5,2,1)}\oplus S^{(5,3)}\\\\
&\oplus 2S^{(6,2)}\oplus S^{(7,1)}\\\\
&\oplus S^{(8)}
\end{align}
only decomposes into $\color{orange}8$.
</script></section><section data-markdown><script type="text/template">
### The decomposition stabilizes

Once ${\color{orange}n}$ is big enough, the decomposition does not change anymore:
\begin{align} 
M^{({\color{orange}n}-4,2,2)}/ \langle(2\enspace 3)\rangle=& S^{({\color{orange}n}-4,2,2)}\oplus S^{({\color{orange}n}-4,4)}\\\\&\oplus S^{({\color{orange}n}-3,2,1)}
\oplus S^{({\color{orange}n}-3,3)}\\\\&\oplus 2S^{({\color{orange}n}-2,2)}
\oplus S^{({\color{orange}n}-1,1)}\\\\&\oplus S^{({\color{orange}n})}
\end{align}

<div class="fragment" data-fragment-index="1">
The <span style="color:orange">block sizes</span> are independent of ${\color{orange}n}$! Under the right normalization, <span style="color:orange">coefficients converge as $n\to\infty$.</span>
</div>
</script></section><section data-markdown><script type="text/template">
### Interpretation: Specht-Flags

<div class="r-stack">
<div class="fragment fade-out" data-fragment-index="1">

Earlier we defined the homomorphism of the semistandard tableau $T$

![](Pic_YoungTabExColor.svg)

to be the function

![](Pic_SemistandardHom.svg)



</div>
<div class="fragment fade-in-then-out" data-fragment-index="1">

![](Pic_SemistandardHom.svg)

Essentially returns an element of $M^{(2,2,1)}$, which has been <span style="color:orange">symmetrized</span> according to the row-stabilizer of $T$:

$$S_{\\{{\color{orange}{a,b,c}}\\}}\times S_{\\{{\color{green}{d,e}}\\}}.$$

</div>

<div class="fragment fade-in-then-out" data-fragment-index="2">

![](Pic_SymGraphTab.svg)

It's the same here: <span style="color:orange">We add symmetries to graphs.</span>

<img class="r-stretch" src="Pic_SymGraph.svg">

<span style="color:orange">Filled vertices</span> are unlabeled vertices, i.e. symmetrized with all not-appearing vertices.

</div>

<div class="fragment fade-in-then-out" data-fragment-index="3">

We are interested in images of <span style="color:orange">polytabloids</span>. The polytabloid of the standard tableaux 

![](Pic_PolytabExA.svg)

is:

![](Pic_PolytabExB.svg)

</div>

<div class="fragment fade-in-then-out" data-fragment-index="4">

Here, this defines a <span style="color:orange">product</span> between <span style="color:orange">graphs with symmetrized vertex groups:</span>

<img class="r-stretch" src="Pic_SpechtFlags.svg">

<img class="r-stretch" src="Pic_SpechtFlagEval.svg">

<span style="color:orange">If the sizes of the vertex groups differ, this product is zero!</span>

</div>

<div class="fragment fade-in" data-fragment-index="5">
We can calculate these products efficiently with help of a generalized version of the algorithm of <span style="color:orange">Dion Gijswijt</span> or the algorithm of <span style="color:orange"> Litjens, Polak, and Schrijver</span>.

</div>



</div>
</script></section></section><section ><section data-markdown><script type="text/template">
## Razborov style hierarchy
#### Prioritizing Flags with <span style="color:orange">few vertices</span>
</script></section><section data-markdown><script type="text/template">
### Nearly symmetric sums of squares

**Raymond et al.:** Every Specht module $S^{(\lambda_1,\ldots,\lambda_m)}$ has an element <span style="color:orange">invariant under $S_{\lambda_1}$.</span>

This tells us that we get a hierarchy <span style="color:orange">equivalent to Lasserre's</span> by optimizing over an SDP indexed by <span style="color:orange">Flags with at most $2d$ labels.</span>
</script></section><section data-markdown><script type="text/template">
### Prioritizing small graphs

<div class="r-stack">

<!-- STACK 1 -->
<div class="fragment fade-out" data-fragment-index="1">

**Razborov** prioritizes Flags with <span style="color:orange">few vertices</span>. Let $\color{green}T$ be the maximum number of vertices we want to appear. 

</div>
<!-- STACK 2 -->

<div class="fragment fade-in-then-out" data-fragment-index="1">
The $\color{green}T$'th level of Razborov's hierarchy is equivalent to optimizing over

$${\color{red}[x]}^T X  {\color{red}[x]},$$

where ${\color{red}[x]}$ contains Flags with $\color{orange}a$ labels in $\\{1,\ldots, {\color{green}T}\\}$ and at most $\lfloor ({\color{green}T}-{\color{orange}a}) / 2\rfloor$ unlabeled vertices.

<span style="color:orange">Additionally we need another decomposition condition.</span>
</div>

<!-- STACK 3 -->
<div class="fragment fade-out" data-fragment-index="4">
<div class="fragment fade-in" data-fragment-index="2">


We require that $X$ can be decomposed into a <span style="color:orange">sum over rank $1$-matrices</span>
$$X = X_1 + \ldots + X_k\quad\text{for some $k$},$$
where each ${\color{red}[x]}^T X_i  {\color{red}[x]}$ contains no graph with more than ${\color{green}T}$ vertices.


<div class="fragment" data-fragment-index="3">

The $X_i$ correspond exactly to the <span style="color:orange">maximal 
cliques</span> in the enforced sparsity pattern!

</div>

</div>

</div>

<!-- STACK 4 -->

<div class="fragment fade-in" data-fragment-index="4">

The sparsity pattern in the case ${\color{green}T}=4$:

![](RazborovSparsity.png)

</div>

</div>

</script></section><section data-markdown><script type="text/template">
### The maximal cliques

Up to symmetry, we obtain a maximal clique for each integer $S\in\\{1,\ldots,{\color{green}T}\\}$ with $S\mod 2 \equiv T$. In the case ${\color{green}T}=4$ these are:

![](Pic_MaxCliques.svg)

</script></section><section data-markdown><script type="text/template">### Breaking Schur's Lemma

<div class="r-stack">
<div class="fragment fade-out" data-fragment-index="2">

<div class="r-frame">

Let $\color{orange}M$, $\color{orange}N$ be two **irreducible** $G$-modules over a ring $R$. Let ${\color{limegreen}\varphi} : {\color{orange}M}\to {\color{orange}N}$ be a homomorphism.

- If $\color{orange}M$ and $\color{orange}N$ are not isomorphic, then ${\color{limegreen}\varphi} \equiv 0$. 
- If ${\color{orange}M}\simeq {\color{orange}N}$ and $R$ is an <span style="color:red">algebraically closed field</span>, then ${\color{limegreen}\varphi} = c\mathrm{I}$ for a $c\in R$. 

</div>

<br/>

<div class="fragment" data-fragment-index="1">
We optimize over $\{0,1\} = \mathbb{Z}_2$, which is <span style="color:orange">not algebraically closed!</span>
</div>

</div>
<div class="fragment fade-in-then-out" data-fragment-index="2">

<img class="r-stretch" src="Pic_BreakingSchurs.svg">

Both modules are <span style="color:orange">isomorphic</span> to the module $M^{(1,1)}$, but also <span style="color:orange">orthogonal</span> to each other, as $x_{12}(1-x_{12}) = 0$.
</div>

<div class="fragment fade-in" data-fragment-index="3">

We obtain <span style="color:orange">one block for each graph with up to $\color{green}T$ vertices</span> by applying a <span style="color:orange">Mbius transformation</span> on the labeled vertices.


<div class="fragment" data-fragment-index="4">
The symmetries of each block are given by the <span style="color:orange">automorphism group</span> of the corresponding graph. <span style="color:red">The symmetry groups are not $S_n$ anymore!</span>
</div>

<br/>

<div class="fragment" data-fragment-index="5">
We can still exploit them computationally with the <span style="color:orange">Jordan reduction method.</span>
</div>

</div>
</div>
</script></section><section data-markdown><script type="text/template">
### Comparing the hierarchies

In the setting of (undirected) graphs we have 
  \begin{equation}
    \mathrm{Las}_{2{\color{orange}d}} \geq \mathrm{Raz} _{4{\color{orange}d}}
  \end{equation}
  and
  \begin{equation}
    \mathrm{Raz} _{\color{green}T} \geq \mathrm{Las} _{2\binom{{\color{green}T}}{2}},
  \end{equation}
where <span style="color:orange">lower means better</span>.</script></section></section><section ><section data-markdown><script type="text/template">
### Graph-profiles

<div class="r-stack">
<div class="fragment fade-out" data-fragment-index="1">

Let $\color{orange}G$ and $\color{green}H$ be two (Quantum-)Graphs.

The <span style="color:orange">Graph-profile</span> of $\color{orange}G$ and $\color{green}H$ is the set of possible values

$$\left\lbrace (p(\mathcal{G}, {\color{orange}G} ), p(\mathcal{G}, {\color{green}H} )) : \mathcal{G} \text{ sequence of graphs}\right\rbrace.$$

</div>
<div class="fragment fade-in-then-out" data-fragment-index="1">

<span style="color:orange">Razborov</span> calculates the <span style="color:orange">triangle</span>-<span style="color:green">edge</span> graph profile [Graphic by <span style="color:orange">Blekherman, Raymond, Singh, Thomas</span>]:

<img src="TriangleProfile.png" width="322" height="282">

<!-- <img class="plain" src="TriangleProfile.png"> -->

<!-- ![](TriangleProfile.png) -->


</div>
<div class="fragment fade-in-then-out" data-fragment-index="2">

We can find an <span style="color:orange">outer approximation</span> of graph profiles by solving

$$\max \int_0^1 f \text{ s.t. } {\color{orange}G} - f({\color{green}H}) \geq 0,$$

for a lower bound, where $f$ is a <span style="color:orange">univariate</span> polynomial. We solve a similar problem for an upper bound.


</div>

<div class="fragment fade-in-then-out" data-fragment-index="3">

One function is not enough:

<center>
<iframe data-src="./Pic_ProfileProblem.html" width="800" height="600" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="margin-bottom:5px; display:block;" ></iframe>
<center/>

</div>
<div class="fragment fade-in" data-fragment-index="4">


Cutting $[0,1]$ into many intervals works well:

<center>
<iframe data-src="./Pic_ProfileSolution.html" width="800" height="600" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="margin-bottom:5px; display:block;" ></iframe>
<center/>

</div>
</div>
</script></section><section data-markdown><script type="text/template">

<img class="r-stretch" src="./graphProfilesMatrix.png">
</script></section><section data-markdown><script type="text/template">
## Harmonic Flags

<center>
<iframe data-src="./Pic_ProfileP2E.html" width="800" height="600" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="margin-bottom:5px; display:block;" ></iframe>
<center/>
</script></section><section data-markdown><script type="text/template">
## Harmonic Flags

<center>
<iframe data-src="./Pic_ProfileP3E.html" width="800" height="600" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="margin-bottom:5px; display:block;" ></iframe>
<center/>









</script></section></section><section  data-markdown><script type="text/template">
### Advanced ideas


- Different limits for <span style="color:orange">degenerate extremal combinatorics</span>.

<span class="fragment">

- Razborov introduces <span style="color:orange">combinatoric partial derivatives</span> in direction of *vertex and edge deletion*. We can generalize them and exploit their symmetries.

</span>
<span class="fragment">

- We define a <span style="color:orange">Fourier transformation</span> on Flags, which results in computational advantages. They also lead to a <span style="color:orange">natural recursive formulation of Sidorenko's conjecture</span>.

</span></script></section><section  data-markdown><script type="text/template">
## Software

A Julia package implementing the fully reduced hierarchies (and much more!) for <span style="color:orange">arbitrary Flags</span> will be available very soon.

--- 

## Paper

Should be online soon-ish. It will be first available as part of <span style="color:orange">my thesis draft</span>.</script></section></div>
    </div>

    <script src="./dist/reveal.js"></script>

    <script src="./plugin/markdown/markdown.js"></script>
    <script src="./plugin/highlight/highlight.js"></script>
    <script src="./plugin/zoom/zoom.js"></script>
    <script src="./plugin/notes/notes.js"></script>
    <script src="./plugin/math/math.js"></script>
    <script>
      function extend() {
        var target = {};
        for (var i = 0; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (source.hasOwnProperty(key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }

      // default options to init reveal.js
      var defaultOptions = {
        controls: true,
        progress: true,
        history: true,
        center: true,
        transition: 'default', // none/fade/slide/convex/concave/zoom
        plugins: [
          RevealMarkdown,
          RevealHighlight,
          RevealZoom,
          RevealNotes,
          RevealMath
        ]
      };

      // options from URL query string
      var queryOptions = Reveal().getQueryHash() || {};

      var options = extend(defaultOptions, {"pdfSeparateFragments":true,"transition":"slide"}, queryOptions);
    </script>

    <script src="./plugins/manim.js"></script>
    <script src="./plugin.js"></script>

    <script>
      Reveal.initialize(options);
    </script>
  </body>
</html>
